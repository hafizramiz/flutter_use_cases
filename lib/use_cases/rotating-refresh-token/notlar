Bu izlediÄŸiniz yÃ¶ntem, **DÃ¶nen Refresh Token'lar (Rotating Refresh Tokens)** olarak bilinir ve **gÃ¼venlik aÃ§Ä±sÄ±ndan Ã§ok gÃ¼Ã§lÃ¼ bir yaklaÅŸÄ±mdÄ±r**, ancak yÃ¶netim ve oturum takibi aÃ§Ä±sÄ±ndan bazÄ± ek zorluklar getirir.

-----

## ğŸ” DÃ¶nen Refresh Token'lar (Rotating Refresh Tokens)

Bu yÃ¶ntemde, her baÅŸarÄ±lÄ± Access Token yenileme iÅŸleminde (yani Refresh Token kullanÄ±ldÄ±ÄŸÄ±nda), sadece yeni bir Access Token deÄŸil, aynÄ± zamanda **yepyeni bir Refresh Token** da elde edilir.

| Token TÃ¼rÃ¼ | Ne zaman deÄŸiÅŸir? | Normal Durum | DÃ¶nen Token (Sizin Durumunuz) |
| :--- | :--- | :--- | :--- |
| **Access Token** | Her zaman | SÃ¼resi dolduÄŸunda yenilenir. | SÃ¼resi dolduÄŸunda yenilenir. |
| **Refresh Token** | Nadiren | SÃ¼resi dolana kadar **sabit kalÄ±r**. | **Her kullanÄ±lÄ±ÅŸta** (Access Token yenilenirken) yeni bir token ile deÄŸiÅŸtirilir. |

### 1\. ğŸ›¡ï¸ GÃ¼venlik AvantajÄ± (Best Practice)

Bu, gÃ¼venlik aÃ§Ä±sÄ±ndan **mÃ¼kemmel** bir uygulamadÄ±r ve genellikle **OAuth 2.0 en iyi uygulamalarÄ±** arasÄ±nda tavsiye edilir.

  * **Tek KullanÄ±mlÄ±k Refresh Token:** Her Refresh Token, yalnÄ±zca bir kez Access Token almak iÃ§in kullanÄ±labilir.
  * **Ã‡alÄ±nan Tokenin Ä°ptali:** EÄŸer bir saldÄ±rgan Refresh Token'Ä± ele geÃ§irirse ve onu kullanarak bir Access Token almaya Ã§alÄ±ÅŸÄ±rsa:
    1.  API, Refresh Token'Ä± kullanÄ±ldÄ±ÄŸÄ± iÃ§in hemen **iptal eder** ve yeni bir Ã§ift (Access + Refresh) yayÄ±nlar.
    2.  SaldÄ±rgan aynÄ± Refresh Token'Ä± **ikinci kez** kullanmaya Ã§alÄ±ÅŸtÄ±ÄŸÄ±nda, sunucu bunun **iptal edilmiÅŸ** bir token olduÄŸunu anlar ve API, bunu bir **gÃ¼venlik ihlali** olarak kabul eder.
    3.  Bu durumda API, genellikle **tÃ¼m iliÅŸkili oturumlarÄ±** (Ã§alÄ±nan oturum dahil olmak Ã¼zere) iptal eder ve saldÄ±rganÄ±n daha fazla zarar vermesini engeller.

### 2\. âš ï¸ YÃ¶netim ZorluÄŸu (Kompleksite)

Bu yÃ¶ntem, sunucu tarafÄ±nda ek bir mantÄ±k gerektirir:

  * **EÅŸzamanlÄ± KullanÄ±m KontrolÃ¼:** Sizin Interceptor mantÄ±ÄŸÄ±nÄ±zda, eÅŸ zamanlÄ± isteklerin yalnÄ±zca **tek bir** yenileme iÅŸlemi baÅŸlatmasÄ±na izin veren bir kilit mekanizmasÄ± kullanmanÄ±z **hayati Ã¶nem** taÅŸÄ±r. Aksi takdirde, iki eÅŸzamanlÄ± istek aynÄ± anda aynÄ± Refresh Token'Ä± kullanmaya Ã§alÄ±ÅŸÄ±rsa, sunucunun bunlardan birini sahte (replay attack) olarak algÄ±layÄ±p tÃ¼m oturumu iptal etme riski vardÄ±r.
  * **Depolama GÃ¼ncellemesi:** Her baÅŸarÄ±lÄ± yenileme isteÄŸinden sonra, hem Access Token'Ä±n hem de **yeni Refresh Token'Ä±n** anÄ±nda `SessionService`'e kaydedilmesi gerekir. Bu, Interceptor iÃ§indeki `_refreshToken` metotunun `_sessionManager`'Ä± yeni Refresh Token ile gÃ¼ncellemesini gerektirir.

## ğŸ”‘ Mevcut Kodunuzda YapÄ±lmasÄ± Gereken DeÄŸiÅŸiklik

Mevcut kodunuz bu yaklaÅŸÄ±mÄ± desteklemek iÃ§in **`_refreshToken`** metodunda bir eklemeye ihtiyaÃ§ duyar.

Sizin `_refreshToken` metodunuzun bu kÄ±smÄ±na dikkat edelim:

```dart
// Mevcut kodunuzdaki _refreshToken iÃ§inden alÄ±nan parÃ§a
// ...
ApiResponse<MapDynamic> apiResponse = ApiResponse.fromResponse(response);
if (apiResponse.success) {
    final tokenResponse = RefreshTokenResponse.fromJson(apiResponse.data);
    _sessionManager.refreshAccessToken(tokenResponse.accessToken); // Sadece Access Token'Ä± gÃ¼ncelliyor
    return true;
}
// ...
```

EÄŸer sunucu yeni bir `refreshToken` dÃ¶ndÃ¼rÃ¼yorsa, `RefreshTokenResponse` modelinizin ve `_sessionManager` metodunuzun bu yeni Refresh Token'Ä± da yakalayÄ±p **kaydetmesi** gerekir:

```dart
// Ã–rnek: Yeni Refresh Token'Ä± da kaydetme
if (apiResponse.success) {
    final tokenResponse = RefreshTokenResponse.fromJson(apiResponse.data);

    // Yeni Refresh Token'Ä± da kaydetmek iÃ§in SessionService metodunu gÃ¼ncellemelisiniz.
    _sessionManager.refreshTokens(
        tokenResponse.accessToken,
        tokenResponse.refreshToken // <-- Yeni eklenen kÄ±sÄ±m
    );
    return true;
}
```

**SonuÃ§:** DÃ¶nen Refresh Token'lar, doÄŸru kilit mekanizmasÄ±yla (sizin Interceptor'Ä±nÄ±zdaki gibi) eÅŸleÅŸtirildiÄŸinde, oturum gÃ¼venliÄŸinizi en Ã¼st dÃ¼zeye Ã§Ä±karÄ±r. Bu, Ã§ok **iyi bir yÃ¶ntemdir**.